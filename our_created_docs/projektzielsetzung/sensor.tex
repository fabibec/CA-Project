\chapter{PmodMAXSONAR}

Der Pmod MAXSONAR besitzt einen MaxBotix® LV-MaxSonar®-EZ1™ Ultraschall Sensor, welcher Entfernungen von 15cm - 648cm mit einer Genauigkeit von 2.54cm messen kann.
Nach einer Power-On-Phase von 250 ms und einer weiteren Wartezeit von ca. 100 ms für die Kalibrierung und erste Messung, kann der Sensor in alle 49 ms eine Distanzmessung durchführen.
\newline

Der Sensor sendet ein Ultraschall-Signal aus, welches von einem Objekt reflektiert wird. Der Sensor misst die Zeit, die das Signal benötigt, um zum Sensor zurückzukehren und berechnet daraus die Entfernung zum Objekt.
Dieser Wert wird auf drei Arten an den Ausgängen dargestellt, zum einen als Spannungssignal, als Pulsweite oder als digitale Zahl per UART. In diesem Projekt wird die Entfernung per UART abgegriffen.
\newline

Die wichtigen Schnittstellen sind daher:

\begin{itemize}
    \item \textit{TX (Transmit Data)}: Pin zur Initialisierung der Sensorkalibrierung und Distanzmessungen
    \item \textit{RX (Receive Data)}: Empfang des Distanzwertes als 5 ASCII-Zeichen mit dem Format "Rxxx\textbackslash r"; \\
        xxx entspricht dem Distanzwert in zoll
\end{itemize}

Um den Sensor nutzen zu können, müssen die Pins TX und RX mit dem FPGA verbunden werden.

\begin{lstlisting}[language=bash,caption={Pin-Zuordnung im Constraints-File},breaklines=true,captionpos=b,basicstyle=\footnotesize\ttfamily,
    label={lst:fpga_pins_maxsonar}]
    set_property -dict {PACKAGE_PIN U16 IOSTANDARD LVCMOS33} [get_ports {tx_out}];
        #pmodmaxsonar rx
    set_property -dict {PACKAGE_PIN V15 IOSTANDARD LVCMOS33} [get_ports {rx_in}];
        #pmodmaxsonar tx
\end{lstlisting}

\section{Ansatz Custom IP}

Im ersten Schritt soll die IP funktional fertiggestellt werden. Sie soll dabei mittels Polling eingesetzt werden. Sobald die Funktionalität des Gesamtsystems vollumfänglich gegeben ist, wird anstatt Polling über Interrupts kommuniziert.\newline
\newline
Das Projektteam hat sich auf folgenden Entwurf geeinigt:

\begin{itemize}
    \item \textit{Submodul 1}: Startup \& Calibration Timer \\
    Während der Startup und Kalibrierungsphase können keine Messungen durchgeführt werden.\\
    Daher wird ein Timer implementiert, der die Zeit bis zur ersten Messung überwacht.
    \item \textit{Submodul 2}: UART Receiver (FSM) \\
    Mittels einer FSM wird der UART Empfang realisiert, dieser empfängt jeweils 1 Byte und meldet den Empfang an den ASCII-Decoder.\\
    Die Baudrate mit Oversampling wird durch einen Clockdivider aus dem Systemtakt generiert.\\
    Bei einem Fehler im Empfangsprozess wird ein Fehler-Flag gesetzt, und die IP beendet den Vorgang mittels des \textit{ap\_done} Signals.
    \item \textit{Submodul 3}: ASCII Decoder (FSM) \\
    Der ASCII Decoder empfängt stückweise die 5 ASCII-Zeichen im Format "R$x_0 x_ 1 x_ 2$\textbackslash r"
    \newline $x_0 \in \{ 0,..,2\}, x_{1,2} \in \{ 0,...,9 \}$.\\
    Wird dieses Format verletzt, wird ein Fehler-Flag gesetzt, und die IP beendet den Vorgang mittles des \textit{ap\_done} Signals.\\
    Nach erfolgreicher Konvertierung steht die Distanz als 8-Bit Zahl in der Einheit zoll (inch) zur Verfügung.
    \item \textit{Submodul 4}: AXI Slave Interface  \\
    Nachdem die Zuverlässigkeit der IP mittels Tests sichergestellt wurde, soll die IP an den internen Systembus (AXI) angebunden werden.
\end{itemize}

Das Registermapping ist an \textit{at\_doc.pdf} aus \textit{02b\_tut\_vhdl\_v03} angelehnt.

\section{Registermapping - \textit{DRAFT}}

\subsection{I/Os}
\begin{longtable}{|p{4cm}|p{1cm}|p{2cm}|p{6.6cm}|}
\hline
\textbf{Signal Name} & \textbf{I/O} & \textbf{Initial State} & \textbf{Description} \\
\hline
ap\_clk(s00\_axi\_aclk) & I & NA & AXI Clock \\
\hline
ap\_rst\_n (s00\_axi\_aresetn) & I & NA & AXI Reset, active-Low \\
\hline
s\_axi\_control* (s00\_axi*) & NA & NA & AXI4-Lite Slave Interface signals \\
\hline
interrupt & I & 0x0 & Indicates that the condition for an interrupt has occurred. (new sensor reading)
\newline 0 = No interrupt has occurred
\newline 1 = Interrupt has occurred \\
\hline
rx\_in & I & NA & UART receive from sensor \\
\hline
tx\_out & O & 1 & UART transmit to sensor \\
\hline
\caption{PmodMAXSONAR I/O}
\end{longtable}

\subsection{Registerbereich}
% PmodCLP Controller Register Mapping in LaTeX with longtables
% Register Space Overview Table
\begin{longtable}{|p{3cm}|p{3cm}|p{8cm}|}
    \hline
    \textbf{Address Offset} & \textbf{Register Name} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Address Offset} & \textbf{Register Name} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{3}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    0x00 & GCSR & General/Global Control and Status Register \\
    \hline
    0x04 & GIER & Global Interrupt Enable Register \\
    \hline
    0x08 & IPIER & IP Interrupt Enable Register \\
    \hline
    0x0C & IPISR & IP Interrupt Status Register \\
    \hline
    0x10 & IDR & ID Register \\
    \hline
    0x14 & VERR & Version Register \\
    \hline
    0x18 & SCSR0 & Special Control and Status Register \\
    \hline
    0x1C & DIST0 & Distance Value Register \\
    \hline
    0x20 & URSR & Distance Value Register \\
    \hline
    0x24 & ADSR & ASCII Decoder Status Register \\
    \hline
    \caption{PmodMAXSONAR Register Space Overview}
    \label{tab:register_overview}
    \end{longtable}

    % GCSR Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{1cm}|p{6.25cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x00 GCSR - General/Global Control and Status Register}} \\
    \hline
    0 & ap\_start & R/W & 0 & Asserted when the kernel is able to do sensor readings. Cleared on handshake with ap\_done being asserted. \\
    \hline
    1 & ap\_done & R & 0 & Asserted when the kernel has completed processing data (with or without error). Cleared on read. \\
    \hline
    2 & ap\_idle & R & 0 & Asserted when the kernel is idle. \\
    \hline
    3 & \textit{reserved (ap\_ready)} & R & 0 & Asserted by the kernel when it is ready to accept new data (used only by AP\_CTRL\_CHAIN) \\
    \hline
    4 & \textit{reserved (ap\_continue)} & R/W & 0 & Asserted by the XRT to allow kernel keep running (used only by AP\_CTRL\_CHAIN) \\
    \hline
    5:6 & reserved & & & \\
    \hline
    7 & auto\_restart & R/W & 0 & Used to enable automatic kernel restart. This bit determines whether only one sensor reading is processed or the sensor reading is continously updated.
    \newline 0 = single reading
    \newline 1 = free running mode \\
    \hline
    31:8 & reserved & & & \\
    \hline
    \caption{General/Global Control and Status Register (GCSR)}
    \label{tab:gcsr}
    \end{longtable}

    % GIER Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{1cm}|p{6.25cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x04 GIER - Global Interrupt Enable Register}} \\
    \hline
    0 & gie & R/W & 0 & When asserted, along with the IP Interrupt Enable bit, the interrupt is enabled. \\
    \hline
    31:1 & reserved & & & \\
    \hline
    \caption{Global Interrupt Enable Register (GIER)}
    \label{tab:gier}
    \end{longtable}

    % IPIER Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{1cm}|p{6.25cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x08 IPIER - IP Interrupt Enable Register}} \\
    \hline
    0 & ipie & R/W & 0 & When asserted, along with Global Interrupt Enable bit, the interrupt is enabled. (default: uses the internal ap\_done signal to trigger an interrupt) \\
    \hline
    31:1 & reserved & & & \\
    \hline
    \caption{IP Interrupt Enable Register (IPIER)}
    \label{tab:ipier}
    \end{longtable}

    % IPISR Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{1cm}|p{6.25cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x0C IPISR - IP Interrupt Status Register}} \\
    \hline
    0 & ipis & R/W & 0 & Toggle on write. (write 1 to clear(W1C)) \\
    \hline
    31:1 & reserved & & & \\
    \hline
    \caption{IP Interrupt Status Register (IPISR)}
    \label{tab:ipisr}
    \end{longtable}

    % IDR Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{2.5cm}|p{4.75cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x10 IDR - ID Register}} \\
    \hline
    31:0 & ID & R & 0x534F4E52 & Distinct ID for PmodMAXSONAR (ASCII for SONR)\\
    \hline
    \caption{ID Register (IDR)}
    \label{tab:idr}
    \end{longtable}

    % VERR Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{2.5cm}|p{4.75cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x14 VERR - Version Register}} \\
    \hline
    31:0 & VER & R & 0x80001000 & Version \\
    \hline
    \caption{Version Register (VERR)}
    \label{tab:verr}
    \end{longtable}

    % SCSR0 Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{1cm}|p{6.25cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x18 SCSR0 - Special Control and Status Register}} \\
    \hline
    0 & powerup\_done & R & 0 & Asserted when the powerup time of the sonar sensor has passed \\
    \hline
    1 & config\_done & R & 0 & Asserted when the configuration of the sonar sensor is done \\
    \hline
    2 & read\_valid & R & 0 & Signals if the current values in the DIST0 Register are valid.
    \newline In single reading mode the flag is asserted when completed a sensor read without an error. When a new reading starts the flag is cleared.
    \newline In free running mode the flag is set when the first error free sensor reading was conducted. If there are errors while reading sensor, the flag should be cleared.
    \\
    \hline
    5:3 & reserved & & & \\
    \hline
    6 & reset\_ip & R & 0 & Stops the whole IP and resets all values \\
    \hline
    7 & freeze\_ip & R & 0 & Stops the whole IP but does not reset the values (useful for debugging) \\
    \hline
    31:8 & reserved & & & \\
    \hline
    \caption{Special Control and Status Register (SCSR0)}
    \label{tab:scsr0}
    \end{longtable}

    % DIST0 Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{1cm}|p{6.25cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x1C DIST0 - Distance Value Register}} \\
    \hline
    15:0 & dist\_cm & R & 0x0000 & Distance in centimeters
    \begin{itemize}
        \item 0x0000 = no valid reading yet
        \item 0x000F - 0x0288
        \item 15cm - 648cm
    \end{itemize}\\
    \hline
    23:16 & dist\_in & R & 0x00 & Distance in inches
    \begin{itemize}
        \item 0x00 = no valid reading yet
        \item 0x06 - 0xFF
        \item 6in - 255in
    \end{itemize}\\
    \hline
    31:24 & reserved & & & \\
    \hline
    \caption{Distance Value Register (DIST0)}
    \label{tab:dist0}
    \end{longtable}

    % URSR Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{1cm}|p{6.25cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x24 URSR - UART Receiver Status Register}} \\
    \hline
    0 & ur\_error & R & 0 & Set to one, if the UART Receiver moves into the error state. Cleared on reset.\\
    \hline
    7:1 & reserved & & & \\
    \hline
    15:8 & ur\_data & R & 0x00 & Current status of the UART Receive Buffer (for Debug Purposes) \\
    \hline
    31:16 & reserved & & & \\
    \hline
    \caption{UART Receiver Status Register (URSR)}
    \label{tab:ursr}
    \end{longtable}

    % ADSR Register Table
    \begin{longtable}{|p{1cm}|p{3cm}|p{2cm}|p{1cm}|p{6.25cm}|}
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endfirsthead
    \hline
    \textbf{Bit} & \textbf{Name} & \textbf{Access Type} & \textbf{Reset Value} & \textbf{Description} \\
    \hline
    \endhead
    \hline \multicolumn{5}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline
    \endlastfoot

    \multicolumn{5}{|c|}{\textbf{0x24 ADSR - ASCII Decoder Status Register}} \\
    \hline
    0 & ad\_error & R & 0 & Set, if the ASCII Decoder moves into error state (the packet structure „Rxxx\textbackslash r“ violated). Cleared on reset. \\
    \hline
    5:1 & ad\_err\_pos & R & 0x00 & One-hot bitmask of the ASCII character which caused the error
    \newline 0x01 = R
    \newline 0x02 = first number
    \newline 0x04 = second number
    \newline 0x08 = third number
    \newline 0x10 = cariage return
    \\
    \hline
    7:6 & reserved & & & \\
    \hline
    15:8 & ad\_err\_char & R & 0x00 & ASCII character which caused the error \\
    \hline
    31:16 & reserved & & & \\
    \hline
    \caption{ASCII Decoder Status Register (ADSR)}
    \label{tab:adsr}
    \end{longtable}


